<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Reversing de IOLI Crackmes con Cutter - Crackme0x03 - xbytemx blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Tony Palma" />
  <meta name="description" content="Hoy toca el 4to crackme de IOLI, el cual nos presenta un reto muy parecido al anterior crackme0x02 solo que usando funciones como veremos más adelante.
" />







<meta name="generator" content="Hugo 0.53" />


<link rel="canonical" href="https://xbytemx.github.io/post/ioli-crackmes-cutter_-_crackme0x03/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Reversing de IOLI Crackmes con Cutter - Crackme0x03" />
<meta property="og:description" content="Hoy toca el 4to crackme de IOLI, el cual nos presenta un reto muy parecido al anterior crackme0x02 solo que usando funciones como veremos más adelante." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xbytemx.github.io/post/ioli-crackmes-cutter_-_crackme0x03/" /><meta property="article:published_time" content="2018-10-28T20:57:33-06:00"/>
<meta property="article:modified_time" content="2018-10-28T20:57:33-06:00"/><meta property="og:site_name" content="xbytemx blog" />

<meta itemprop="name" content="Reversing de IOLI Crackmes con Cutter - Crackme0x03">
<meta itemprop="description" content="Hoy toca el 4to crackme de IOLI, el cual nos presenta un reto muy parecido al anterior crackme0x02 solo que usando funciones como veremos más adelante.">


<meta itemprop="datePublished" content="2018-10-28T20:57:33-06:00" />
<meta itemprop="dateModified" content="2018-10-28T20:57:33-06:00" />
<meta itemprop="wordCount" content="1980">



<meta itemprop="keywords" content="crackme,ioli,cutter,radare,reversing," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reversing de IOLI Crackmes con Cutter - Crackme0x03"/>
<meta name="twitter:description" content="Hoy toca el 4to crackme de IOLI, el cual nos presenta un reto muy parecido al anterior crackme0x02 solo que usando funciones como veremos más adelante."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">xbytemx blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">xbytemx blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Reversing de IOLI Crackmes con Cutter - Crackme0x03</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-10-28 </span>
        <div class="post-category">
            
              <a href="/categories/reversing/"> reversing </a>
            
              <a href="/categories/elf32/"> ELF32 </a>
            
          </div>
        <span class="more-meta"> 1980 palabras </span>
        <span class="more-meta"> 10 mins lectura </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contenidos</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#footprint">Footprint</a></li>
<li><a href="#entrypoints">Entrypoints</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#disassembly">Disassembly</a>
<ul>
<li><a href="#función-main">Función main</a></li>
<li><a href="#función-test">Función test</a></li>
<li><a href="#función-shift">Función shift</a></li>
</ul></li>
<li><a href="#grafico">Grafico</a>
<ul>
<li><a href="#función-main-1">Función main</a></li>
<li><a href="#función-test-1">Función test</a></li>
<li><a href="#función-shift-1">Función shift</a></li>
</ul></li>
<li><a href="#validación">Validación</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>Hoy toca el 4to crackme de IOLI, el cual nos presenta un reto muy parecido al anterior crackme0x02 solo que usando funciones como veremos más adelante.</p>

<h2 id="footprint">Footprint</h2>

<p>Comenzamos por obtener información sobre el crackme, siguiendo el mismo proceso con la finalidad de identificar algún cambio sobre lo hecho anteriormente en otros crackmes.</p>

<p><img src="/img/cutter04/initial.png" alt="Initial info about crackme0x03" /></p>

<p>Nuevamente tenemos otro ELF32 muy parecido a los anteriores.</p>

<p>Carguemos el archivo directo a Cutter con los valores de análisis por defecto:</p>

<p><img src="/img/cutter04/load.png" alt="Loading crackme on Cutter" /></p>

<p>En el dashboardno vemos mucha diferencia sobre los retos anteriores:</p>

<p><img src="/img/cutter04/dashboard.png" alt="Dashboard de crackme0x03" /></p>

<h2 id="entrypoints">Entrypoints</h2>

<p>Comenzamos por analizar todos los entry points de este ejecutable:</p>

<p><img src="/img/cutter04/entrypoint.png" alt="Entry Point de crackme0x03" /></p>

<p>Como podemos ver, el programa unicamente cuenta con un entrypoint, <strong>0x8048360</strong>.</p>

<h2 id="strings">Strings</h2>

<p>Los strings dentro de este ejecutable son (ojo con la dirección):</p>

<p><img src="/img/cutter04/strings.png" alt="Strings de crackme0x03" /></p>

<p>Sobre salen los strings:</p>

<p><img src="/img/cutter04/strings2.png" alt="Strings largos de crackme0x03" /></p>

<p>Estos mantienen cierta longitud sobre los demás datos que se traducen. También sobre sale por su proximidad con los strings conocidos (.rodata). Veamos como son usados mas adelante.</p>

<h2 id="imports">Imports</h2>

<p>En la sección de imports, veremos que nuevamente llamamos a nuestras funciones de costumbre, mas una adicional strlen:</p>

<p><img src="/img/cutter04/imports.png" alt="Imports de crackme0x03" /></p>

<blockquote>
<p>Se nos advierte que tanto la función scanf, como strlen son funciones inseguras.</p>
</blockquote>

<h2 id="functions">Functions</h2>

<p>Ahora toca revisar las funciones que tenemos en nuestro programa, las cuales son las siguientes:</p>

<p><img src="/img/cutter04/functions.png" alt="Funciones de crackme0x03" /></p>

<p>Tenemos ahora una variación con los retos anteriores, tenemos no solo sym.main y las importadas, sino ahora tenemos a sym.shift y sym.test</p>

<p>También dentro de las importadas tenemos ahora a sym.imp.strlen.</p>

<h2 id="disassembly">Disassembly</h2>

<h3 id="función-main">Función main</h3>

<p>Comencemos a realizar el análisis estático para conocer que sucede dentro de este programa. Comenzemos por la funcion principal, main:</p>

<p><img src="/img/cutter04/dis1.png" alt="Disassembly de crackme0x03" /></p>

<blockquote>
<p>Trate de reducir un poco el tamaño de la letra para que fuera visible toda la función main.</p>
</blockquote>

<p>Como vemos es bastante similar al reto anterior, solo que ya no tenemos la parte comparativa y en su lugar tenemos una llamada a la función test. Llegaremos a esto después de entender la primera parte.</p>

<p>Aplicando la misma metodología que hemos manejado:</p>

<p><img src="/img/cutter04/dis2.png" alt="Stack Frame de crackme0x03" /></p>

<p>Primero tenemos el stack frame, que como hemos visto antes nos ayuda a separar lo que las variables locales usaran posteriormente.</p>

<p><img src="/img/cutter04/dis3.png" alt="Welcome de crackme0x03" /></p>

<p>Continuamos con la primera llamada a printf, el cual recibe de parámetro el string &ldquo;IOLI Crackme Level 0x03\n&rdquo;, dando inicio al primer mensaje que vemos en pantalla.</p>

<p><img src="/img/cutter04/dis4.png" alt="Ask for password de crackme0x03" /></p>

<p>Continuamos con la segunda llamada a printf, la cual recibe de parámetro el string &ldquo;Password: &ldquo;, manteniendo el cursor sin salto de linea.</p>

<p><img src="/img/cutter04/dis5.png" alt="scanf de crackme0x03" /></p>

<p>La siguiente parte toma la variable local_4h y carga su posición en memoria sobre EAX, para después guardar dicho valor en local_4h_2. La siguiente parte carga en el stack pointer el valor de lo ubicado en 0x8048634. Finalmente scanf es llamado en donde usara el valor de la ubicación 0x8048634 y la ubicación en memoria de local_4h.</p>

<p>Traducimos esta referencia para ver que valor tiene el const chr *format.
&gt; Recordemos que para ir a una posición debemos dar dos clicks izq sobre la misma.</p>

<p><img src="/img/cutter04/integer.png" alt="Integer" /></p>

<p><img src="/img/cutter04/scanf-1.png" alt="1er parámetro de scanf" /></p>

<p>Ahora sabemos que el valor que reciba se guardara como entero sobre el segundo parámetro.</p>

<p>Como en el crackme anterior, renombraremos los parámetros local_4h y local_4h_2 para que sean mas legibles mas adelante.
&gt; Hotkey: shift + n</p>

<p><img src="/img/cutter04/scanf-2.png" alt="2do parámetro de scanf" /></p>

<p>Ahora que hemos realizado lo mismo del ejercicio anterior, donde determinamos el tipo de variable que estaremos usando y las renombramos, continuemos con el siguiente bloque de instrucciones:</p>

<p><img src="/img/cutter04/dis6.png" alt="Operaciones matemáticas" /></p>

<p>Este bloque lo resolvimos en el ejercicio anterior, el cual en pseudocódigo queda como el siguiente:</p>

<pre><code>i = 90
j = 492
i += j
i *= i
j = i
</code></pre>

<p>Renombramos las variables para homologar:</p>

<p><img src="/img/cutter04/dis7.png" alt="i y j" /></p>

<p>Terminando las instrucciones anteriores que si conocemos, sigue una serie de asociaciones:</p>

<p><img src="/img/cutter04/dis9.png" alt="Load to Stack" /></p>

<p>Aquí lo que sucede es:</p>

<pre><code>EAX = j
ESP+0x4 = EAX
EAX = num
ESP = EAX
</code></pre>

<p>Básicamente colocamos en el stack dos variables para que cuando llamemos a test, las pueda retirar (parámetros). El stack debe quedarnos parecido a lo siguiente:</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>La instrucción siguiente es <strong>call sym.test</strong>, la cual carga en el stack la dirección de la siguiente instrucción dentro de la función main. Acto seguido, brincamos a sym.test que inicia en <em>0x0804846e</em>.</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<blockquote>
<p>Cuando retornemos de esta función, las siguientes instrucciones corresponden al <em>return 0;</em> del programa.</p>
</blockquote>

<p>La idea general de como seria esto implementado en C seria como el siguiente código:</p>

<pre><code class="language-c">int main(int argc, char **argv, char **envp){
  int num, i, j;
  printf(&quot;IOLI Crackme Level 0x03\n&quot;);
  printf(&quot;Password: &quot;);
  scanf(&quot;%d&quot;, &amp;num);

  i = 90;
  j = 492;
  i += j;
  i *= i;
  j = i;

  test(num, j);

  return 0;
}
</code></pre>

<h3 id="función-test">Función test</h3>

<p>Analicemos lo que hace la función test, para ello damos doble click izq sobre el nombre la función para ir a ese lugar. La función completa es la siguiente:</p>

<p><img src="/img/cutter04/dis11.png" alt="Función test" /></p>

<p>Ahora enfocándonos en la primera parte de la función, el stack frame:</p>

<p><img src="/img/cutter04/dis12.png" alt="Stack Frame - test" /></p>

<p>Esta describe que se salve el EBP en el stack, después asignamos EBP = ESP. Recordar que el call sube la ubicación a ESP de la siguiente instrucción que continua después del call:</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0xc</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Y se resta 8 direcciones al ESP. Actualizando nuestra tabla imaginaria del stack:</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0x8</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP-0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Finalizamos el stack frame aquí en <em>0x08048471</em>, y haciendo las resoluciones, EBP = ESP-0x8. Esto es importante para analizar la siguiente parte.</p>

<p><img src="/img/cutter04/dis13.png" alt="valor ingresado, valor a comparar" /></p>

<p>Ahora lo que vemos es que EAX recibe el valor de arg_8h, el cual equivale a EBP+0x8, osea el valor num de main.</p>

<p>Después hacemos un cmp entre EAX (num) y arg_ch, el cual equivale a EBP+0xc, osea el valor 0x52b24 (2do argumento)</p>

<blockquote>
<p>Renombraremos arg_8h como num1 y arg_ch como num2.</p>
</blockquote>

<p><img src="/img/cutter04/dis17.png" alt="rename nums" /></p>

<p>Esto nos hace una clara idea de que acabamos de ejecutar un <em>if</em>:</p>

<pre><code class="language-c">if (num1 == num2)
</code></pre>

<p>Continuemos con la siguiente instrucción:</p>

<p><img src="/img/cutter04/dis14.png" alt="Verdadero" /></p>

<p>Si num1 es igual a num2 (<strong>338724</strong>), entonces subimos el string _str.Lqydolg<em>Sdvvzrug</em> al ESP:</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0x8</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP-0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP</td>
<td>str.Lqydolg_Sdvvzrug</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Y ejecutamos <strong>call sym.shift</strong></p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0x8</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP-0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP</td>
<td>0x08048488</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>str.Lqydolg_Sdvvzrug</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0xc</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Con esto hemos brincado a otra función, por lo que dejaremos este caso hasta aquí.</p>

<blockquote>
<p>Al retornar, unicamente ejecutaríamos el <em>jmp 0x08048496</em>.</p>
</blockquote>

<p><img src="/img/cutter04/dis15.png" alt="Falso" /></p>

<p>Si num1 es diferente a num2 (<strong>338724</strong>), entonces subimos el string _str.Sdvvzrug<em>RN</em> al ESP:</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0x8</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP-0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP</td>
<td>str.Sdvvzrug_RN</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Y ejecutamos <strong>call sym.shift</strong></p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0x8</td>
<td>EBP</td>
</tr>

<tr>
<td>ESP-0x4</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP</td>
<td>0x08048488</td>
</tr>

<tr>
<td>ESP+0x4</td>
<td>str.Sdvvzrug_RN</td>
</tr>

<tr>
<td>ESP+0x8</td>
<td>num</td>
</tr>

<tr>
<td>ESP+0xc</td>
<td>0x52b24</td>
</tr>
</tbody>
</table>

<p>Con esto hemos brincado a otra función, por lo que dejaremos este caso hasta aquí.</p>

<p><img src="/img/cutter04/dis16.png" alt="if completo" /></p>

<p>Finalmente, la vista completa; sea como sea, llamamos a shift con diferentes strings. Uno para el caso verdadero otro para el caso falso. Después de terminar el if, retornamos a <strong>main</strong> con las insutrcciones <em>leave</em> y <em>ret</em>.</p>

<p>El codigo en C pudiera ser el siguiente:</p>

<pre><code class="language-C">void test(int num1, unsigned int num2){
  if (num1 == num2) shift(&quot;Lqydolg#Sdvvzrug$&quot;);
  else shift(&quot;Sdvvzrug#RN$$$#=,&quot;);
}
</code></pre>

<h3 id="función-shift">Función shift</h3>

<p>Toca turno ahora a la función shift, que hasta donde conocemos, recibe de argumento un string. Veamos que tenemos en toda la función:</p>

<p><img src="/img/cutter04/dis21.png" alt="Funcion shift" /></p>

<p>Se ve mas extensa que la anterior función test. Comencemos por el stack frame:</p>

<p><img src="/img/cutter04/dis22.png" alt="Stack frame - shift" /></p>

<p>Tenemos gracias al análisis de la función, el argumento char s* y tres variables tipo int.</p>

<p>Salvamos el EBP actual en el stack y le asignamos el valor de ESP. Finalizamos con mover el ESP unas 0x98 direcciones &hellip; 152 posiciones nada mas.</p>

<table>
<thead>
<tr>
<th>dirección</th>
<th>valor</th>
</tr>
</thead>

<tbody>
<tr>
<td>ESP-0xa0</td>
<td>EBP.main</td>
</tr>

<tr>
<td>ESP-0x9c</td>
<td>0x08048511</td>
</tr>

<tr>
<td>ESP-0x98</td>
<td>EBP.test</td>
</tr>

<tr>
<td>ESP-0x94</td>
<td>0x08048488</td>
</tr>

<tr>
<td>ESP-0x90</td>
<td>str.Sdvvzrug_RN</td>
</tr>

<tr>
<td>ESP-0x8c</td>
<td>num</td>
</tr>

<tr>
<td>ESP-0x88</td>
<td>0x52b24</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>

<tr>
<td>ESP</td>
<td>0x00000000</td>
</tr>
</tbody>
</table>

<p><img src="/img/cutter04/dis23.png" alt="strlen" /></p>

<p>En el siguiente bloque de instrucciones, movemos a ESP-0x7c el valor de 0, subimos a EAX el string correspondiente (EBP+0x8 aka ESP-0x90) y guardamos dicho valor en ESP (ESP vale ahora EAX, osea s)</p>

<p>Realizamos la llamada a <a href="https://www.programiz.com/c-programming/library-function/string.h/strlen">strlen</a> vía <strong>call sym.imp.strlen</strong>. Si conocemos un poco esta función sabemos que debe devolver un valor natural, el cual se guarda en EAX.</p>

<p><img src="/img/cutter04/dis24.png" alt="i &lt;= len(s)" /></p>

<p>Las siguientes instrucciones hacen lo siguiente; comparo si ESP-0x7c (actualmente con valor de 0) es igual o mayor al valor retornado de strlen de s. Luego tomo la decisión en el jae (jmp if great o equal unsigned), siendo verdadero brincamos, siendo falso continuamos con la siguiente instrucción.</p>

<p>Esto es una clara referencia a un tipo de loop que sera mas claro cuando encontremos el jmp de retorno a este punto de comparación y salida.</p>

<p>La comparación que tenemos entre manos es:</p>

<pre><code>if (0 &lt; strlen(s))
</code></pre>

<p>Continuemos al siguiente bloque.</p>

<p><img src="/img/cutter04/dis25.png" alt="incrementa el index" /></p>

<p>El siguiente bloque carga ESP-0x78 en EAX, y después salva el valor de ESP-0x78 en EDX. La idea es después sumar ESP-0x7c (actualmente con valor de 0) en ESP-0x78, aquí es donde haríamos una iteración de ESP-0x78 si el valor de ESP-0x7c cambia. Después guardaríamos ESP-0x7c (actualmente con valor de 0) en EAX para el siguiente bloque.</p>

<p>Esto seria como el siguiente pseudocódigo para la primera pasada:</p>

<pre><code>EDX = ESP-0x78 + 0
EAX = 0
</code></pre>

<p><img src="/img/cutter04/dis26.png" alt="shift!" /></p>

<p>Continuamos con las siguientes instrucciones, la comienza con la suma de ESP-0x78 (valor 0) con la ubicación del string que esta en .rodata (recordar que depende del valor verdadero o falso del if), si nos fijamos esto seria iterar la ubicación del carácter del string, algo como cuando tenemos un s[i] dentro de un código&hellip;</p>

<p>Ok, continuando con la instrucción 2, tenemos algo interesante, <strong>movzx eax, byte [eax]</strong> toma el primer byte de la ubicación de s y lo guarda en EAX. Lo demás lo llena de ceros.</p>

<p>Después, <strong>sub al, 3</strong> resta 3 al valor almacenado en EAX, por ejemplo si su valor era 0x43 &copy; ahora valdrá 0x41 (A).</p>

<p>La siguiente instrucción salva este byte en EDX, es decir, si se convirtió a 0x41, este valor se salva en el primer byte de EDX.</p>

<p><img src="/img/cutter04/dis27.png" alt="final del loop" /></p>

<p>Continuamos cargando la ESP-0x7c en EAX, incrementamos el valor de ESP-0x7c (antes 0, ahora 1) y salvamos en EAX. Ejecutamos un jmp de retorno a 0x08048424 (donde empezamos a preparamos para el strlen).</p>

<p>Con esto finalizamos el loop, pero &hellip; ¿que rayos paso?</p>

<p>Si tuviera que traducirlo a código en C seria como el siguiente:</p>

<pre><code class="language-c">char buf[100];
int i;

for (i = 0; i &lt; strlen(s); i++)
{
  buf[i] = (char) s[i] - 3;
}
</code></pre>

<p>Yo se que en ninguna parte se crea ese buf de ese tamaño definido ni que tampoco se hace el cast de char de operaciones en entero, pero lo agregue para darle un poco de practicidad.</p>

<p><img src="/img/cutter04/dis28.png" alt="string final" /></p>

<p>Después de acabar este for, salvamos la dirección ESP-0x78 (buf) en EAX. Sumamos el valor de ESP-0x7c (ahora strlen(s)-1) sobre el valor de EAX (la dirección ESP-0x78).</p>

<p>La ultima instrucción, <strong>mov byte[eax], 0</strong> escribe el byte 0x00 sobre la ultima ubicación para cortar el <em>buffer</em> y de esa manera poner el carácter null. Ahora si, tenemos un string hecho y derecho en el buffer.</p>

<p><img src="/img/cutter04/dis29.png" alt="printf final" /></p>

<p>Bueno, tenemos un string en el buffer, retornamos ESP-0x78 a EAX con la primera instrucción, luego con la segunda guardamos ese valor (la dirección del stack) sobre ESP-0x4 y finalmente en la tercera instrucción cargamos en el stack el string &ldquo;%s\n&rdquo;.
&gt; Me ahorre las vueltas a la ubicación en memoria para decodificar el string constante que recibe printf</p>

<p>Por supuesto esto fue un preludio para la llamada a printf, donde el primer argumento define que se recibirá un string y el segundo argumento es el string en si que hemos manejado de buffer.</p>

<p>Renombrando todas nuestras variables tenemos un código en C como el siguiente:</p>

<pre><code class="language-c">void shift(char *s){
  char buf[100];
  int i;

  for (i = 0; i &lt; strlen(s); i++) buf[i] = (char) s[i] - 3;
  printf(&quot;%s\n&quot;, buf);
}
</code></pre>

<p>Renombrando en el disassembly también nos queda de la siguiente manera:</p>

<p><img src="/img/cutter04/dis20.png" alt="funcion shift final" /></p>

<h2 id="grafico">Grafico</h2>

<p>Los grafos de nuestras 3 funciones son:</p>

<h3 id="función-main-1">Función main</h3>

<p><img src="/img/cutter04/graph-main.png" alt="Graph main" /></p>

<h3 id="función-test-1">Función test</h3>

<p><img src="/img/cutter04/graph-test.png" alt="Graph test" /></p>

<h3 id="función-shift-1">Función shift</h3>

<p><img src="/img/cutter04/graph-shift.png" alt="Graph shift" /></p>

<h2 id="validación">Validación</h2>

<p>Hemos llegado a la parte final, donde validamos la conclusión a la que hemos realizado después del análisis estático, en la cual la contraseña que debemos ingresar en el crackme es <strong>338724</strong>, misma del reto anterior.</p>

<p>Validemos:</p>

<p><img src="/img/cutter04/validacion.png" alt="Validación" /></p>

<p>Excelente! Hemos resuelto el cuarto crackme de IOLI.</p>

<hr />

<p>Bueno eso ha sido todo de momento, espero que les haya gustado.
Saludos,</p>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/crackme/">crackme</a>
          
          <a href="/tags/ioli/">ioli</a>
          
          <a href="/tags/cutter/">cutter</a>
          
          <a href="/tags/radare/">radare</a>
          
          <a href="/tags/reversing/">reversing</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/ioli-crackmes-cutter_-_crackme0x04/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Reversing de IOLI Crackmes con Cutter - Crackme0x04</span>
            <span class="prev-text nav-mobile">Previo</span>
          </a>
        
          <a class="next" href="/post/ioli-crackmes-cutter_-_crackme0x02/">
            <span class="next-text nav-default">Reversing de IOLI Crackmes con Cutter - Crackme0x02</span>
            <span class="next-text nav-mobile">Siguiente</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'xbytemx';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/xbytemx" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/xbytemx" class="iconfont icon-github" title="github"></a>
  <a href="https://xbytemx.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Creado con <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Tema - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Tony Palma</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
